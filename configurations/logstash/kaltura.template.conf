input {
	file {
		path => "@LOG_DIR@/kaltura_api_v3.log"
		type => "api_v3"
		add_field => { "format" => "kalturaServer" }
	}
	file {
		path => "@LOG_DIR@/kaltura_prod.log"
		type => "core"
		add_field => { "format" => "kalturaServer" }
	}
	file {
		path => "@LOG_DIR@/batch/*.log"
		type => "batch"
		add_field => { "format" => "kalturaClient" }
	}
	file {
		path => "@LOG_DIR@/kaltura_admin.log"
		type => "admin"
		add_field => { "format" => "kalturaClient" }
	}
	file {
		path => "@LOG_DIR@/kaltura_multi_publishers.log"
		type => "var"
		add_field => { "format" => "kalturaClient" }
	}
	file {
		path => "@LOG_DIR@/kaltura_apache_access.log"
		type => "access"
	}
	file {
		path => "@LOG_DIR@/kaltura_apache_error.log"
		type => "error"
	}
}

filter {
	
	if [type] == "access" {
		grok {
#			match => ["message", "%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{NOTSPACE:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:status} %{NUMBER:bytes} %{NUMBER:seconds}/%{NUMBER:microseconds} \"(?<referrer>[^\"]+)\" \"(?<userAgent>[^\"]+)\" \"(?<f5Https>[^\"]+)\" %{NOTSPACE:f5RemoteAddress} \"(?<xKaltura>[^\"]+)\" \"(?<hostname>[^\"]+)\" %{NUMBER:processId} %{NUMBER:sessionId} (?<connectionStatus>[X+-]) %{NUMBER:bytesReceived} \"(?<contentRange>[^\"]+)\" \"(?<xForwardedFor>[^\"]+)\" \"(?<xForwardedServer>[^\"]+)\" \"(?<xForwardedHost>[^\"]+)\" \"(?<cacheControl>[^\"]+)\" %{NUMBER:partnerId} %{IPORHOST:f5ExtIp} %{NOTSPACE:f5ExtHops}"]
			match => ["message", "%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{NOTSPACE:request} HTTP/%{NUMBER:httpversion}\" %{NUMBER:status} %{NUMBER:bytes} %{NUMBER:seconds}/%{NUMBER:microseconds} \"(?<referrer>[^\"]+)\" \"(?<userAgent>[^\"]+)\" \"(?<uv>[^\"]+)\" %{IPORHOST:remoteip} \"(?<xKaltura>[^\"]+)\" \"(?<hostname>[^\"]+)\" %{NUMBER:processId} %{NUMBER:sessionId} (?<connectionStatus>[X+-]) %{NUMBER:bytesReceived} \"(?<contentRange>[^\"]+)\" \"(?<xForwardedFor>[^\"]+)\" \"(?<xForwardedServer>[^\"]+)\" \"(?<xForwardedHost>[^\"]+)\" \"(?<cacheControl>[^\"]+)\" %{NUMBER:partnerId}"]
			tag_on_failure => "wrong_format"
		}
	}
	
	if [type] == "error" {
		grok {
			match => ["message", "\[%{HTTPDATE:timestamp}\] \[%{WORD:level}\] \[client %{IPORHOST:clientip}\]"]
			tag_on_failure => "wrong_format"
		}
	}
	
	if [format] == "kalturaServer" {
		multiline {
			pattern => "^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}"
			negate => true
			what => "previous"
		}
		grok {
			match => ["message", "^(?<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[%{NUMBER:duration}\] \[%{IP:ip}\] \[%{NUMBER:session_id}\] \[%{WORD:context}\] \[(?<method>[^\]]+)\] %{WORD:level}:"]
			tag_on_failure => "wrong_format"
		}
		date {
			match => [ "timestamp" , "yyyy-MM-dd HH:mm:ss" ]
			timezone => "Asia/Jerusalem"
		}
		grok {
			match => ["message", "Event \[%{WORD:eventType}\] object type \[%{WORD:objectType}\] id \[%{WORD:objectId}\]"]
		}
		grok {
			match => ["message", "Event \[%{WORD:eventType}\] job id \[%{NUMBER:objectId}\] type \[%{NUMBER:jobType}\] sub type \[%{NUMBER:jobSubType}\] status \[%{NUMBER:jobStatus}\]"]
		}
		grok {
			match => ["message", "consumer \[%{WORD:consumer}\] started handling \[%{WORD:objectType}\]"]
			add_tag => [ "consumerStart" ]
		}
		grok {
			match => ["message", "consumer \[%{WORD:consumer}\] finished handling \[%{WORD:objectType}\]"]
			add_tag => [ "consumerEnd" ]
		}
		if [eventType] == "kBatchJobStatusEvent" {
			mutate {
				add_field => { "objectType" => "BatchJob" }
			}
		}
	}
	
	if [type] == "core" {
		grok {
			match => ["message", "\{sfRequest\} request parameters array \(  'module' => '%{WORD:service}',  'action' => '%{WORD:action}',"]
			add_tag => "title"
		}
	}
	
	if [type] == "api_v3" {
		grok {
			match => ["message", "Dispatching service \[%{WORD:service}\], action \[%{WORD:action}\]"]
			add_tag => "title"
		}
		if [message] =~ ">------------------------------------- api_v3 --" {
			mutate {
				add_tag => "start"
			}
		}
		else if [message] =~ "<------------------------------------- api_v3 --" {
			mutate {
				add_tag => "end"
			}
		}
	}
	
	if [format] == "kalturaClient" {
		multiline {
			pattern => "^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}"
			negate => true
			what => "previous"
		}
		grok {
			match => ["message", "^(?<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[%{NUMBER:duration}\] \[%{NUMBER:session_id}\] \[%{WORD:context}\] \[(?<method>[^\]]+)\] %{WORD:level}:"]
			tag_on_failure => "wrong_format"
		}
		date {
			match => [ "timestamp" , "yyyy-MM-dd HH:mm:ss" ]
			timezone => "Asia/Jerusalem"
		}
		grok {
			match => ["message", "\/api_v3\/index\.php\?service=%{WORD:apiService}&action=%{WORD:apiAction}"]
			add_tag => [ "api_call" ]
		}
		grok {
			match => ["message", "server: \[%{WORD:apiServer}\], session: \[%{WORD:apiSession}\]"]
			add_tag => [ "api_session" ]
		}
	}
	
	if [type] == "batch" {
		grok {
			match => ["path", "^%{WORD:worker}-%{NUMBER:batchIndex}-"]
		}
		if [message] =~ "___________________________________________________________________________________" {
			mutate {
				add_tag => "start"
			}
		}
		grok {
			match => ["message", "Done after \[%{NUMBER:sessionDuration}\] seconds"]
			add_tag => [ "end" ]
		}
		grok {
			match => ["message", "Start job\[%{NUMBER:jobId}\] type\[%{WORD:jobType}\] sub-type\[%{WORD:jobSubType}\] object\[%{WORD:objectType}\] object-id\[%{WORD:objectId}\] partner-id\[%{NUMBER:partnerId}\] dc\[%{NUMBER:dc}\] parent-id\[%{NUMBER:parentJobId}\] root-id\[%{NUMBER:rootJobId}\]"]
			add_tag => [ "jobStart" ]
		}
		grok {
			match => ["message", "End job\[%{NUMBER:jobId}\]"]
			add_tag => [ "jobEnd" ]
		}
	}
}

output {
	elasticsearch { host => @ELASTIC_SEARCH_HOST@ }
	# stdout { codec => dots }
}
